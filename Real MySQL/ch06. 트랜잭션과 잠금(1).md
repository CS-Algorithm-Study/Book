## 6장. 트랜잭션과 잠금

### 잠금(Lock)

- 동시성을 제어하기 위한 기능
- 하나의 회원 정보를 여러 커넥션에서 동시에 변경하려고 할 때, Lock이 없다면 여러 커넥션에서 동시에 변경할 수 있게 되고, 결과적으로 해당 레코드는 예측 불가능한 상태가 된다
- Lock은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해준다

### 트랜잭션

- 데이터의 정합성을 보장하기 위한 기능
- **격리 수준**
    - 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨
- **트랜잭션 사용 시 주의사항**
    - 꼭 필요한 최소의 코드에만 적용하는 것이 좋다(**트랜잭션의 범위를 최소화**)
    - 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 것이고, 어느 순간에는 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있다
    - 특히 네트워크를 통해 원격 서버와 통신하는 작업(메일 전송, FTP 파일 전송)은 트랜잭션 내에서 제거하는 것이 좋다

### MySQL 엔진의 잠금
- **글로벌 락**
    - MySQL에서 제공하는 잠금 중 가장 범위가 크다
    - 일단 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 를 제외한 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다
    - 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체(작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 적용됨) → 서버에 존재하는 모든 테이블을 닫고 잠금을 검
    - ‘FLUSH TABLES WITH READ LOCK’ 명렁으로 획득 가능
    - 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는 것이 좋다
    - mysqldump 같은 백업 프로그램은 우리가 알지 못하는 사이에 이 명령을 내부적으로 실행하고 백업할 때도 있다
    
- **테이블 락**
    - 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다
    - 특별한 상황이 아니면 명시적 락은 사용할 필요가 거의 없다
    - 묵시적 락은 MyIASM이나 MEMORY 테이블에서 데이터를 변경하는 쿼리를 실행하면 발생하고, 변경이 끝나면 즉시 잠금을 해제하는 형태로 사용된다
    - 하지만 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고, 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다
    
- **네임드 락**
    - 임의의 **문자열**에 대해 잠금을 설정할 수 있다
    - 이 잠금의 특징은 대상이 테이블이나 레코드와 같은 데이터베이스 객체가 아니라는 것이다
    - 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리에서 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류하여 네임드 락을 걸고 사용하면 데드락을 피할 수 있다
    - ex.
    
    ```java
    // 'mylock' 이라는 문자열에 대해 잠금을 획득한다.
    // 이미 잠금을 사용 주잉면 2초 동안만 대기한다. (2초 이후 자동 잠금 해제)
    SELECT GET_LOCK('mylock', 2);
    
    // 'mylock' 이라는 문자열에 대해 잠금이 설정돼 있는지 확인한다.
    SELECT IS_FREE_LOCK('mylock');
    
    // 'mylock' 이라는 문자열에 대해 획득했던 잠금을 반납(해제)한다
    SELECT RELEASE_LOCK('mylock');
    
    // 3개 함수 모두 정상적으로 락을 획득하거나 해제한 경우엔느 1을, 아니면 NULL이나 0을 반환
    ```
    
- **메타데이터 락**
    - 데이터베이스 객체(대표적으로 테이블이나 뷰)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다
    - 명시적으로 획득하거나 해제할 수 있는 락이 아니며 ‘RENAME TABLE tab_b TO tab_a’ 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다
    - ex.
        - 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터를 생성
        - 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업하고
        - 새로 만들어진 랭킹 테이블(rank_new)를 서비스용으로 대체하고자 하는 경우
        
        ```java
        RENAME TABLE rank TO rank_backup , rank_new TO rank;
        ```
        
        - 위와 같이 하나의 RENAME TABLE 명령문에 두 개의 RENAME 작업을 한꺼번에 실행하면 실제 어플리케이션에서는 ‘table not found “rank”’ 같은 상황을 발생시키지 않고 적용하는 것이 가능하다
        - 만약 위 명령을 따로 따로 나눠서 하는 경우, rank 테이블이 존재하지 않는 순간이 생기며 그 순간에 실행되는 쿼리는 ‘table not found “rank”’ 오류를 발생시킨다
